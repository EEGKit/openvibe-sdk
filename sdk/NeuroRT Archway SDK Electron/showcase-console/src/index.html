<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
    <style type="text/css">
html {
  padding:0;
}
body {
  padding: 0;
  margin :0;
  display: flex;
  height: 100vh;
  flex-direction: column;
  font-family: sans-serif;
}
main {
  margin: 10px 10px 0 10px;
  background: #efefef;
  overflow-y: scroll;
  flex: 2;

  white-space:break-all;
  font-family:monospace;
}
aside {
  margin: 10px 10px 0 10px;
  background: #333333;
  color: #20f050;
  overflow-y: scroll;
  overflow-x: scroll;
  flex: 1;

  font-family:monospace;
}
footer {
  margin: 10px;
}

#statusbar {
  display:flex;
  flex-direction: row;
  margin: 10px 10px 0 10px;
}
.left, .right {
  flex: 1;
}
.right {
  text-align:right;
}

#toolbar {
  margin: 10px 10px 0 10px;
}

.error {
  color:#d02020;
}

.event {
  color:#e0d020;
  font-weight:bold;
}

    </style>
    <script type="text/javascript">
// Get the Electron object
var remoteElectronApp = require('remote');
// Get the Archway object
var archway = require('../../SDK/archway-node');

// HTML elements in which we will display text
var outputElement = null;
var outputValuesElement = null;

// Whether we are currently reading data from Archway
var acquisitionLoopRunning = false;

// The javascript timeout object (so we can stop the loop when necessary)
var acquisitionLoopTimeout = null;

// Holds the ID of the monitoring pipeline we will create in the NeuroRT Engine
var echoPipelineId = null;

// This program works with an Echo pipeline with the following structure
/*
 Signal received from        Events received from
 the first Acquisition       Archway
 Device
 +---------------------+     +---------------------+
 |                     |     |                     |
 | Mensia Input Signal |     | Mensia Input Events |
 |                     |     |                     |
 |       Device 0      |     |     Channel 1       |
 |                     |     |                     |
 +----------+----------+     +----------+----------+
            |                           |
            |                           |
            V                           V
 +----------------------+   +----------------------+
 |                      |   |                      |
 | Mensia Output Signal |   | Mensia Ouptut Events |
 |                      |   |                      |
 |       Channel 1      |   |      Channel 1       |
 |                      |   |                      |
 +----------------------+   +----------------------+
*/

// The number of channels available on the first acquisition device
// We will use this value to correctly display incoming values
var firstAcquisitionDeviceChannelCount = null;

// The count of all samples we have received from the pipeline since the start of Archway
var totalSamplesReceived = 0;

// The amount of lines currently printed in the signal output console
var totalLinesPrinted = 0;

/**
  * Print the string into the div element serving as a console
  */
function log(string, displayTime) {
  if (typeof displayTime === 'undefined') {
    displayTime = true;
  }

  if (displayTime) {
    var date = new Date();
    outputElement.innerHTML +=
      date.getHours() + ':' +
      date.getMinutes() + ':' +
      (date.getSeconds() < 10 ? '0' + date.getSeconds() : date.getSeconds());
  }

  outputElement.innerHTML += " " + string.replace(/\n/, "<br>");

  // Scroll to the end of the display element
  outputElement.scrollTop = outputElement.scrollHeight;
}

/**
  * Print the string containing the values into the output window
  */
function logValues(values) {
  // Our pipeline sends signal by buffers of M samples per channel
  var samplesPerChannel = values.length / firstAcquisitionDeviceChannelCount;

  totalSamplesReceived += samplesPerChannel;

  // Go through all of the received samples, scanning channels first
  for (var sample = 0; sample < samplesPerChannel; sample++) {
    for (var channel = 0; channel < firstAcquisitionDeviceChannelCount; channel++) {
      // Format the string for the received value
      var currentSampleValue = values[sample + channel * samplesPerChannel];
      outputValuesElement.innerHTML += ' ' + currentSampleValue.toFixed(2);
    }
    outputValuesElement.innerHTML += '<br>';
    totalLinesPrinted++;

    // We only display values for the first sample for each channel
    if (sample > 0) {
      break;
    }
  }

  // Clear the buffer when it gets too long
  if (totalLinesPrinted > 50) {
    outputValuesElement.innerHTML = '';
    totalLinesPrinted = 0;
  }

  // Scroll to the end of the display element
  outputValuesElement.scrollTop = outputValuesElement.scrollHeight;
}

/**
  * Print a received event into the console
  */
function logEvent(event) {
  outputValuesElement.innerHTML += '<span class="event">Received an event with code [' + event + ']</span><br>';
}


/**
  * Get the last error code that occured in Archway
  * Get the corresponding message in English
  * Return object containing both
  */
function getLastError(api) {
  var errorCode = api.getLastError();
  var errorMessage = api.getErrorString(errorCode);
  return {
    code: errorCode,
    message: errorMessage
  }
}

// Uninitialize archway if it is initialized
// This is useful when testing the application as Electron does not reload the
// plugins when the webpage is refreshed.

if (archway.isStarted()) {
  archway.stopEngine();
}
if (archway.isAcquiring()) {
  archway.stopAllAcquisitionDevices();
}
if (archway.isInitialized()) {
  archway.uninitialize();
}

/**
  * Get the last error code and the associated message from Archway
  * Print them into the console
  */
function logError(error) {
  if (!error) {
    error = getLastError(archway);
  }
  log("<span class='error'>  Error [0x" + error.code + "] : " + error.message + "</span>\n");
}

/**
  * Checks the status of the Archway library and the Engine
  * Fills the statusbar with this information
  */
function checkArchwayStatus() {
  var status = {
    initialized: archway.isInitialized(),
    acquiring: archway.isAcquiring(),
    started: archway.isStarted(),
    connected: archway.isConnected()
  }

  document.querySelector('#archway-initialized').innerText = status.initialized ? "Yes" : "No";
  document.querySelector('#archway-acquiring').innerText = status.acquiring ? "Yes" : "No";
  document.querySelector('#archway-started').innerText = status.started ? "Yes" : "No";
  document.querySelector('#archway-connected').innerText = status.connected ? "Yes" : "No";

}

/**
  * Starts executing a loop which calls the archway.mainloop() every 10ms
  */
function startAcquisitionLoop() {
  if (acquisitionLoopRunning) {
    return;
  }
  log("Starting the acquisition loop\n");

  acquisitionLoopRunning = true;

  (function acquisitionLoop() {
    acquisitionLoopTimeout = setTimeout( function () {
      if (!acquisitionLoopRunning) {
        return;
      }

      if (!archway.mainloop()) {
        logError();
        acquisitionLoopRunning = false;
        clearTimeout(acquisitionLoopTimeout);
      }

      // As long as there is data available on the 1st channel of the monitor pipeline
      while (archway.getPendingValueCount(echoPipelineId, 1) > 0) {

        // NOTE: the getPendingValue function can throw error if the Archway is not started, initialized etc.
        try {
          var values = archway.getPendingValue(echoPipelineId, 1);
          logValues(values);
        } catch (archwayError) {
          logError(archwayError);
        }
      }

      // Get the pending events from the pipeline
      while (archway.getPendingEventCount(echoPipelineId, 1)) {
        var event = archway.getPendingEvent(echoPipelineId, 1);
        logEvent(event);
      }

      acquisitionLoop();
    }, 10);
  })();

}

function stopAcquisitionLoop() {
  log("Stopping the acquisition loop\n");
  acquisitionLoopRunning = false;
  clearTimeout(acquisitionLoopTimeout);
}

// ------------------------------------------------------
// COMPOUND CALLS
//
// initializeAndStart will initialize the archway, start the acquisition and
// the engine in a sequence.
//
// stopAndUninitialize will stop the engine, stop the devices and uninitialize
// the Archway
//
// ------------------------------------------------------


/**
  * Initialize Archway connection to the Engine
  *
  */
function initializeAndStart() {

  if (!archway.isInitialized() && !archway.isStarted() && !archway.isAcquiring()) {

    log('Initializing Archway...\n');

    // Launch the Archway initialization promise
    archway.asyncInitialize('login', 'password', 'showcase-console', 'config.conf').then( function () {
      // The promise has resolved, we can now start the Acquisition Devices
      log('Archway initialized\n');

      // Initialize all acquisition devices
      return archway.asyncStartAllAcquisitionDevices();
    }).then( function () {
      // The devices have been initialized, we can now create and setup the pipelines
      log('Acquisition devices started\n');

      // Check the acquisition device status
      var acquisitionDeviceCount = archway.getAcquisitionDeviceCount();
      log('Connected acquisition devices: ' + acquisitionDeviceCount + '\n');

      // Display status of each of the devices
      for (var device = 0; device < acquisitionDeviceCount; device++) {
        log('Device ' + device + '\n');

        // Name
        log('|  Name              : ' + archway.getAcquisitionDeviceName(device) + '\n');

        // Whether the device is currently acquiring
        log('| Acquiring          : ' + (archway.isAcquisitionDeviceAcquiring(device) ? 'True' : 'False') + '\n');

        // Whether the device is real or simulated
        log('| Real               : ' + (archway.isAcquisitionDeviceReal(device) ? 'True' : 'False') + '\n');

        // The overall quality of the connection to the device
        log('| Connection Quality : ' + archway.getAcquisitionDeviceConnnectionQuality(device) + '\n');

        // Sampling rate
        log('|  Sampling Rate     : ' + archway.getAcquisitionDeviceSamplingRate(device) + '\n');

        // Channel Count
        var channelCount = archway.getAcquisitionDeviceChannelCount(device);
        log('|  Channel Count     : ' + channelCount + '\n');

        // Channel Names
        var channelLogMessage = '|  Channels : [';

        for (var channel = 0; channel < channelCount; channel++) {
          channelLogMessage += archway.getAcquisitionDeviceChannelName(device, channel) + (channel != channelCount - 1 ? ', ' : '');
        }

        channelLogMessage += ']\n';
        log(channelLogMessage);
      }

      // Save the channel count of the first device, this will be useful for later
      firstAcquisitionDeviceChannelCount = archway.getAcquisitionDeviceChannelCount(0);

      // Create an Echo pipeline, this pipeline has identifier 0x0 and simply returns the data
      // as it was recorded by the EEG device
      // This pipeline sends results back in the following manner:
      // Pipeline Channel 1 : Matrix of signal MxN, M samples per buffer, N = channel count of the device
      // i.e.: it sends M samples per channel in each buffer
      echoPipelineId = archway.createPipeline(0x0, "");
      if (echoPipelineId != 0) {
        log('Echo pipeline created\n');
      } else {
        log('Failed to create the Echo pipeline\n');
        return Promise.reject(getLastError(archway));
      }

      // Once the pipelines were initialized and set-up we can start the Engine
      return archway.asyncStartEngine();
    }).then( function () {
      // Engine has been started, each subsequent call to mainloop() will now send data to the
      // it for processing.
      log('Engine started\n');

      // We can now start looping on mainloop() function and receive processed values from Archway
      log('Starting acquisition loop...\n');
      startAcquisitionLoop();
    }).catch( function (error) {
      // If an error occurs we log the message
      console.log(error);
      logError();

      // And we roll back the status of the Archway, we use synchronous functions for simplicity
      if (archway.isStarted()) {
        log('Stopping Engine... ');
        archway.stopEngine();
        log('OK\n', false);
      }
      if (archway.isAcquiring()) {
        log('Stopping acquisition devices... ');
        archway.stopAllAcquisitionDevices();
        log('OK\n', false);
      }
      if (archway.isInitialized()) {
        log('Uninitializing Engine... ');
        archway.uninitialize();
        log('OK\n', false);
      }
    });

  }
}

/**
  * Stop all acquisition devices
  * Stop the Engine
  * Uninitialize Archway
  */
function stopAndUninitialize() {

  // Archway can not be stopped when it is not started
  if (archway.isInitialized() && archway.isStarted() && archway.isAcquiring()) {

    // Stop polling the Engine for new results, stop sending EEG to the Engine
    log('Stopping acquisition loop...\n');
    stopAcquisitionLoop();

    log('Stopping Archway...\n');

    // First, stop the processing Engine Server
    archway.asyncStopEngine().then( function () {
      log('Acquisition devices stopped\n');

      // After that, stop all of the acquisition devices
      // NOTE: it is also possible to restart the Engine at this point, by simply calling archway.startEngine()
      // or re-launching the start Promise.
      return archway.asyncStopAllAcquisitionDevices();
    }).then( function () {
      log('Archway stopped\n');

      // Release the Echo pipeline
      if (archway.releasePipeline(echoPipelineId)) {
        log('Echo pipeline released\n');
      } else {
        log('Failed to release the pipeline');
        return Promise.reject(getLastError(archway));
      }
      // Finally, un-initialize Archway
      return archway.asyncUninitialize();
    }).then( function () {
      log('Archway uninitialized\n');
   }).catch( function (error) {
      // Log any encountered errors into the console
      console.log(error);
      logError();
    });

  }
}

// ------------------------------------------------------
// SEPARATED CALLS
//
// These calls use the simple, synchronous API to control the Archway
// ------------------------------------------------------


// Initialize Archway, this will connect to the Engine
function initialize() {
  if (archway.initialize('login', 'password', 'application_name', 'config.conf')) {
    log('Archway initialized\n');
  } else {
    logError();
  }
}

// Start Acquiring EEG from all configured devices
function startDevices() {
  if (archway.startAllAcquisitionDevices()) {
    log('Acquisition devices started\n');

    // Save the number of channels of the first acquisition device, we will need this
    // to display the incoming values correctly
    firstAcquisitionDeviceChannelCount = archway.getAcquisitionDeviceChannelCount(0);
  } else {
    logError();
  }
}

// Create the Echo pipeline and start sending data from Archway to the Engine
// Also start looping on the mainloop() call to get data
function start() {
  // Create the Echo pipeline
  echoPipelineId = archway.createPipeline(0x0, "");
  if (echoPipelineId != 0) {
    log('Echo pipeline created\n');
  } else {
    log('Failed to create the Echo pipeline\n');
    logError();
    return;
  }

  // Start the Engine processing
  if (archway.startEngine()) {
    log('Engine started\n');

    // Start the local mainloop() loop
    startAcquisitionLoop();
  } else {
    logError();
  }
}

// Stop the processing loop and the Engine
function stop() {
  if (acquisitionLoopRunning == true) {
    stopAcquisitionLoop();
  }

  // Stop the Engine
  if (archway.stopEngine()) {
    log('Engine stopped\n');
   } else {
    logError();
    return;
  }

  // Release the Echo pipeline
  if (archway.releasePipeline(echoPipelineId)) {
    log('Echo pipeline released\n');
  } else {
    log('Failed to release the pipeline\n');
    logError();
  }

}

// Stop acquiring data from the EEG devices
function stopDevices() {
  if (archway.stopAllAcquisitionDevices()) {
    log('Acquisition devices stopped\n');
  } else {
    logError();
  }
}

// Uninitialize Archway and disconnect from the Engine
function uninitialize() {
  if (archway.uninitialize()) {
    log('Archway uninitialized\n');
  } else {
    logError();
  }
}


/**
  * Send a trigger to the monitoring pipeline
  */
function sendTrigger() {
  if (archway.isStarted()) {
    // Sends a trigger with number 100 to the engine, on the echo pipeline
    archway.triggerEvent(echoPipelineId, 1, 100);
  } else {
    logError({message : 'The engine must be started to be able to receive triggers'});
  }
}


document.addEventListener("DOMContentLoaded", function(event) {
  outputElement = document.querySelector('#console');
  outputValuesElement = document.querySelector('#result-console');
  log('Current Archway version:' + archway.getVersionDescription() + "\n");

  // Start polling the Archway status to update the statusbar
  var pollStatusInterval = setInterval( checkArchwayStatus, 500 );
});
   </script>

  </head>
  <body>
    <header>
      <div id="statusbar">
        <div class="left">
          NeuroRT JavaScript Electron SDK
        </div>
        <!-- Statusbar monitoring the Archway and Engine status -->
        <div class="right">
          Initialized : <span id="archway-initialized"></span> |
          Acquiring : <span id="archway-acquiring"></span> |
          Connected : <span id="archway-connected"></span> |
          Started : <span id="archway-started"></span>
        </div>
      </div>
      <!-- Toolbar with command buttons -->
      <div id="toolbar">
        Compound calls:
        <button onClick="initializeAndStart()">Initialize and Start</button>
        <button onClick="stopAndUninitialize()">Stop and Uninitialize</button><br>
        Separated calls:
        <button onClick="initialize()">Initialize</button>
        <button onClick="startDevices()">Start devices</button>
        <button onClick="start()">Start Engine</button>
        <button onClick="stop()">Stop Engine</button>
        <button onClick="stopDevices()">Stop devices</button>
        <button onClick="uninitialize()">Uninitialize</button>
        <button onClick="sendTrigger()">Send a trigger</button>
      </div>
    </header>
    <!-- Console for displaying status of the Application -->
    <main id="console"></main>
    <!-- Console for displaying the values received from the Engine -->
    <aside id="result-console"></aside>
    <footer>
      © Mensia Technologies
    </footer>

  </body>
</html>
