SET(DOC_PROJECT_NAME "@DOC_PROJECT_NAME@")
SET(DOC_PROJECT_VERSION "@DOC_PROJECT_VERSION@")
SET(DOC_PROJECT_PRODUCT_NAME "@DOC_PROJECT_PRODUCT_NAME@")
SET(DOC_PROJECT_BRANCH "@PROJECT_BRANCH@")
SET(DOC_PROJECT_COMMITHASH "@DOC_PROJECT_COMMITHASH@")
SET(DOC_PROJECT_CPP_SOURCES "@DOC_PROJECT_CPP_SOURCES@")

SET(DOC_PROJECT_SOURCE_DIR "${DOC_PROJECT_NAME}")
SET(DOC_DOXY_INPUT "${DOC_PROJECT_SOURCE_DIR} ${DOC_PROJECT_CPP_SOURCES}")
SET(DOC_FINAL_PATH "${CMAKE_CURRENT_LIST_DIR}/../doc/${DOC_PROJECT_NAME}")

SET(DOC_DOXYGEN_BIN "@DOXYGEN_BIN@")
SET(DOC_HHC_BIN "@HHC_BIN@")
SET(DOC_LATEX_BIN "@LATEX_BIN@")
SET(DOC_GHOSTSCRIPT_BIN "@GHOSTSCRIPT_BIN@")
SET(DOC_DEFINES "@DOC_DEFINES@")
SET(DOC_ENABLED_SECTIONS "@DOC_ENABLED_SECTIONS@")

# Make the final documentation directory

FILE(MAKE_DIRECTORY "${DOC_FINAL_PATH}")
FILE(MAKE_DIRECTORY "${DOC_FINAL_PATH}/html")
FILE(MAKE_DIRECTORY "${DOC_FINAL_PATH}/latex")
FILE(MAKE_DIRECTORY "${DOC_FINAL_PATH}/../${DOC_PROJECT_PRODUCT_NAME}")

# looks for resources and stores thm in a list
SET(resource_files "")
FILE(GLOB_RECURSE resource_files_tmp "${DOC_PROJECT_NAME}/*.png" "${DOC_PROJECT_NAME}/*.svg" "${DOC_PROJECT_NAME}/*.css" "${DOC_PROJECT_NAME}/*.php")
SET(resource_files ${resource_files} ${resource_files_tmp})

IF(resource_files)
	MESSAGE(STATUS "  Found resources...")
	FOREACH(current_resource ${resource_files})
		GET_FILENAME_COMPONENT(current_resource_stripped ${current_resource} NAME)
		MESSAGE(STATUS "    [  OK  ] Resource file ${current_resource}")
		FILE(COPY "${current_resource}" DESTINATION "${DOC_FINAL_PATH}/html/")
		FILE(COPY "${current_resource}" DESTINATION "${DOC_FINAL_PATH}/latex/")
	ENDFOREACH(current_resource)
ENDIF(resource_files)


# Create .dox parts from .dox-part and .dox-skeleton files
FILE(GLOB_RECURSE doxs "${DOC_PROJECT_NAME}/box-algorithm-doc/dox-part/*.dox-part")
FOREACH(dox ${doxs})
	GET_FILENAME_COMPONENT(dox_filename ${dox} NAME_WE)
	# MESSAGE(STATUS "             Documentation part found ${dox}")
	
	SET(dox_tag_name NOTFOUND)

	# iterates on each line of the file to look after begin/end tags
	# "dox_tag_name" stores the name of the variable
	# to use to configure the skeleton file. It is computed from the
	# begin tag.
	FILE(READ ${dox} dox_lines)
	# replaces empty cariage returns with semi colons to be compliant
	# with CMake lists. note the space before and after the semi
	# colon, this is for CMake not to skip empty lines
	STRING(REPLACE "\n" " ; " dox_lines " ${dox_lines} ")
	STRING(REPLACE "BRAND_NAME" "@BRAND_NAME@" dox_lines " ${dox_lines} ")
	STRING(REPLACE "STUDIO_NAME" "@STUDIO_NAME@" dox_lines " ${dox_lines} ")
	FOREACH(dox_line ${dox_lines})
		# this regex removes the spaces we added before the loop
		STRING(REGEX REPLACE "^ (.*) $" "\\1" dox_line ${dox_line})

		# we initialize several variables that will be used in
		# this loop
		SET(dox_line_processed   FALSE)
		SET(dox_tag_begin NOTFOUND)
		SET(dox_tag_end   NOTFOUND)
		SET(dox_tag       NOTFOUND)

		# and look for a new tag in this line
		STRING(REGEX MATCH "\\|[a-zA-Z0-9_]*\\|" dox_tag "${dox_line}")
		IF(dox_tag)
			# a tag is found, so we want to know if it is a
			# OVP_DocBegin* or OVP_DocEnd* tag
			STRING(REGEX MATCH "\\|OVP_DocBegin_[a-zA-Z0-9_]*\\|" dox_tag_begin "${dox_line}")
			STRING(REGEX MATCH "\\|OVP_DocEnd_[a-zA-Z0-9_]*\\|"   dox_tag_end   "${dox_line}")

			# in case we already have something in
			# dox_tag_name, it means that begin tag has
			# already been processed, so either we terminate with end
			# tag, either we continue with come content to add in the
			# variable
			IF(dox_tag_name AND dox_tag_end)
				# in case we find end tag, we just terminate cleaning
				# the tag and what follows. We then terminate and
				# create a new CMake variable with the content of this
				# begin/end tagged things.
				STRING(REGEX REPLACE ".*\\|OVP_DocEnd_([a-zA-Z0-9_]*)\\|.*" "\\1" dox_tag_name_check ${dox_line})
				STRING(REGEX REPLACE   "\\|OVP_DocEnd_([a-zA-Z0-9_]*)\\|.*" "" dox_line "${dox_line}")

				# MESSAGE(STATUS "             - Completed tag pair |${dox_tag_name}|")

				SET(dox_tag_name_value "${dox_tag_name_value}\n${dox_line}")
				SET("Doc_${dox_tag_name}_Content" ${dox_tag_name_value})
				SET(dox_tag_name NOTFOUND)
				SET(dox_line_processed TRUE)
			ENDIF(dox_tag_name AND dox_tag_end)

			# in case dox_tag_name is empty, it means
			# that begin tag has not yet been found, so we just look at it
			# or skip to next line
			IF(NOT dox_tag_name AND dox_tag_begin)
				# in case we find begin tag, we just start saving the
				# CMake variable name, and clean the tag and what
				# comes before. We then intialize the content of the
				# begin/end tagged thing with what comes after begin
				# tag.
				STRING(REGEX REPLACE ".*\\|OVP_DocBegin_([a-zA-Z0-9_]*)\\|.*" "\\1" dox_tag_name ${dox_line})
				STRING(REGEX REPLACE ".*\\|OVP_DocBegin_([a-zA-Z0-9_]*)\\|" "" dox_line "${dox_line}")
				SET(dox_tag_name_value "${dox_line}")
				SET(dox_line_processed TRUE)
			ENDIF(NOT dox_tag_name AND dox_tag_begin)

			# in case dox tag is not OVP_DocBegin* or OVP_DocEnd*
			# just print a warning and continue
			IF(NOT dox_line_processed)
				MESSAGE(STATUS "             - Unexpected tag ${dox_tag} will be ignored")
			ENDIF(NOT dox_line_processed)
		ENDIF(dox_tag)

		# in case this line was not processed, either because it does
		# not have any tag, either because the tag was unexpected, we
		# just append the whole line to the content of the current
		# variable
		IF(dox_tag_name AND NOT dox_line_processed)
			# in case we don't find the end tag, just append this
			# new line to the current content
			SET(dox_tag_name_value "${dox_tag_name_value}\n${dox_line}")
		ENDIF(dox_tag_name AND NOT dox_line_processed)
	ENDFOREACH(dox_line)

ENDFOREACH(dox)

# now we have stored all the begin/end tagged things in variable, we just
# have to configure the skeleton configuration files with those variables.
# note that the skeleon files should be prepared to receive the CMake
# variables with @CMakeVariableName@ anywhere it is needed.
#
# in order to do so, we look after all the (.dox-skeleton) files and call
# the configure command to build the final documentation (.dox) file.
FILE(GLOB_RECURSE dox_skeletons "${DOC_PROJECT_NAME}/box-algorithm-doc/dox/*.dox-skeleton")
FILE(WRITE "${DOC_FINAL_PATH}/../${DOC_PROJECT_PRODUCT_NAME}/${DOC_PROJECT_PRODUCT_NAME}.txt" "# This file was generated, it contains the list of files available in documentation.")
FOREACH(dox_skeleton ${dox_skeletons})
	GET_FILENAME_COMPONENT(dox_skeleton_filename ${dox_skeleton} NAME_WE)
	GET_FILENAME_COMPONENT(dox_skeleton_path     ${dox_skeleton} PATH)
	
	IF(EXISTS "${DOC_PROJECT_NAME}/box-algorithm-doc/dox-part/${dox_skeleton_filename}.dox-part")
		CONFIGURE_FILE(
			"${dox_skeleton}"
			"${DOC_PROJECT_SOURCE_DIR}/${dox_skeleton_filename}.dox"
			@ONLY)
		MESSAGE(STATUS "    [  OK  ] Configured skeleton ${dox_skeleton}")
		FILE(APPEND "${DOC_FINAL_PATH}/../${DOC_PROJECT_PRODUCT_NAME}/${DOC_PROJECT_PRODUCT_NAME}.txt" "${dox_skeleton_filename}\n")
	ELSE()
		EXECUTE_PROCESS(
			COMMAND ${CMAKE_COMMAND} -E remove "${dox_skeleton}"
			WORKING_DIRECTORY "${DOC_PROJECT_NAME}/box-algorithm-doc/dox"
			)
		MESSAGE(STATUS "    [ WARN ] Skeleton ${dox_skeleton} has no dox-part, skeleton removed.")
	ENDIF()
ENDFOREACH(dox_skeleton)

# We copy the file Doc_BoxAlgorithms.dox file generated by the plugin inspector
# along with the dox-part-skeletons
#IF(EXISTS "${DOC_PROJECT_NAME}/box-algorithm-doc/dox/Doc_BoxAlgorithms.dox")
#EXECUTE_PROCESS(
#	COMMAND ${CMAKE_COMMAND} -E copy "box-algorithm-doc/dox/Doc_BoxAlgorithms.dox" "."
#	WORKING_DIRECTORY "${DOC_PROJECT_NAME}"
#	)
#ENDIF()

# the final doxyfile filename is generated, platform compliantly
SET(ov_doxy_final "${DOC_PROJECT_NAME}/doxyfile")
IF(WIN32)
	STRING(REPLACE "/" "\\" ov_doxy_final ${ov_doxy_final})
ENDIF(WIN32)

# doxygen input can be extended if a file source-list.txt exists
# LABO: Feature disabled as there are lots of latex errors to handle. I also includes mensia's include folders.

# IF(EXISTS "${DOC_PROJECT_NAME}/source-list.txt")
	# FILE(READ "${DOC_PROJECT_NAME}/source-list.txt" source_locations)
	# STRING(REGEX REPLACE ";" "\\\\;" source_locations "${source_locations}")
	# STRING(REGEX REPLACE "\n" " " source_locations "${source_locations}")
# ENDIF()
# SET(DOC_DOXY_INPUT "${DOC_DOXY_INPUT} ${source_locations}")

# these lines configure the variables used to configure the doxyfile
SET(ov_doxy_input ${DOC_DOXY_INPUT})
SET(ov_doxy_strip_from_path ${DOC_DOXY_INPUT})
SET(ov_doxy_version @OV_GLOBAL_VERSION_STRING@)
SET(m_doxy_version  @MENSIA_GLOBAL_VERSION_STRIN@})
SET(ov_doxy_output_directory ${DOC_FINAL_PATH}/)
SET(ov_doxy_project_name ${DOC_PROJECT_PRODUCT_NAME})
SET(ov_doxy_defines ${DOC_DEFINES})
SET(ov_doxy_enabled_sections ${DOC_ENABLED_SECTIONS})
SET(BRAND_NAME @BRAND_NAME@)
SET(STUDIO_NAME @STUDIO_NAME@)

SET(ov_doxy_header_project_name ${DOC_PROJECT_NAME}-documentation)
SET(ov_doxy_header_version @OV_GLOBAL_VERSION_STRING@)
SET(m_doxy_header_version  @MENSIA_GLOBAL_VERSION_STRING@)
SET(ov_doxy_header_branch ${DOC_PROJECT_BRANCH})
STRING(REGEX REPLACE "_" "-" ov_doxy_header_branch "${ov_doxy_header_branch}")
SET(ov_doxy_header_hash ${DOC_PROJECT_COMMITHASH})
IF(DOC_PROJECT_PRODUCT_NAME)
	SET(ov_doxy_header_product_name ${DOC_PROJECT_PRODUCT_NAME})
ELSE(DOC_PROJECT_PRODUCT_NAME)
	SET(ov_doxy_header_product_name ${DOC_PROJECT_NAME})
ENDIF(DOC_PROJECT_PRODUCT_NAME)

# configure doxyfile to generate a .chm file if available
# HHC_BIN may or may not be set
IF(DOC_HHC_BIN)
	SET(ov_doxy_generate_chm YES)
	SET(ov_doxy_hhc_location "\"${DOC_HHC_BIN}\"")
	SET(ov_doxy_chm_file "\"../../${DOC_PROJECT_PRODUCT_NAME}/${DOC_PROJECT_PRODUCT_NAME}.chm\"")
ELSE()
	SET(ov_doxy_generate_chm NO)
ENDIF()

# configure doxyfile to generate a latex->PDF file if available
# LATEX_BIN / GHOSTSCRIPT_BIN may or may not be set
IF(DOC_LATEX_BIN AND DOC_GHOSTSCRIPT_BIN)
	SET(ov_doxy_generate_latex YES)
ELSE()
	SET(ov_doxy_generate_latex NO)
ENDIF()

# the doxyfile is configured
IF(EXISTS "${DOC_PROJECT_NAME}/openvibe.dox-part")
	CONFIGURE_FILE(
		${DOC_PROJECT_NAME}/openvibe.dox-part
		${DOC_PROJECT_NAME}/openvibe.dox
		@ONLY)
ENDIF()
# the doxyfile is configured
CONFIGURE_FILE(
	${DOC_PROJECT_NAME}/doxyfile-skeleton
	${ov_doxy_final}
	@ONLY)
# the latex header
CONFIGURE_FILE(
	${DOC_PROJECT_NAME}/header.tex-skeleton
	${DOC_PROJECT_NAME}/header.tex
	@ONLY)
# and the html header
CONFIGURE_FILE(
	${DOC_PROJECT_NAME}/header.html-skeleton
	${DOC_PROJECT_NAME}/header.html
	@ONLY)

# executing doxygen
EXECUTE_PROCESS(
	COMMAND "${DOC_DOXYGEN_BIN}" -u "${DOC_PROJECT_NAME}/doxyfile"
	#WORKING_DIRECTORY "${DOC_PROJECT_NAME}"
	)

EXECUTE_PROCESS(
	COMMAND "${DOC_DOXYGEN_BIN}" "${DOC_PROJECT_NAME}/doxyfile"
	#WORKING_DIRECTORY "${DOC_PROJECT_NAME}"
	)

MESSAGE(STATUS "Creating Archive ${CMAKE_COMMAND}")
EXECUTE_PROCESS(
	COMMAND ${CMAKE_COMMAND} -E tar cfz "../${DOC_PROJECT_PRODUCT_NAME}/${DOC_PROJECT_PRODUCT_NAME}.tar.gz" "html"
	WORKING_DIRECTORY "${DOC_FINAL_PATH}"
	)
	
IF(DOC_LATEX_BIN AND DOC_GHOSTSCRIPT_BIN)
	IF(WIN32)
		MESSAGE(STATUS "Building LaTeX documentation")
		EXECUTE_PROCESS(
			COMMAND make.bat
			WORKING_DIRECTORY ${DOC_FINAL_PATH}/latex
			)
	ELSE()
		EXECUTE_PROCESS(
			COMMAND make -C .
			WORKING_DIRECTORY ${DOC_FINAL_PATH}/latex
			)
	ENDIF()
	EXECUTE_PROCESS(
		COMMAND ${CMAKE_COMMAND} -E copy "latex/refman.pdf" "../${DOC_PROJECT_PRODUCT_NAME}/${DOC_PROJECT_PRODUCT_NAME}.pdf"
		WORKING_DIRECTORY ${DOC_FINAL_PATH}
		)
ENDIF()

FILE(REMOVE_RECURSE ${DOC_FINAL_PATH})
