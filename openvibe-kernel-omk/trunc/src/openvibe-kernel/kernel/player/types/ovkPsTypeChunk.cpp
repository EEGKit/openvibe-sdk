///12/09/2006at18:00:29/// Time signature, do not change this line

/************************************************************************/
/* This file is part of openMask(c) INRIA, CNRS, Universite de Rennes 1 */
/* 1993-2002, thereinafter the Software                                 */
/*                                                                      */
/* The Software has been developped within the Siames Project.          */
/* INRIA, the University of Rennes 1 and CNRS jointly hold intellectual */
/* property rights                                                      */
/*                                                                      */
/* The Software has been registered with the Agence pour la Protection  */
/* des Programmes (APP) under registration number                       */
/* IDDN.FR.001.510008.00.S.P.2001.000.41200                             */
/*                                                                      */
/* This file may be distributed under the terms of the Q Public License */
/* version 1.0 as defined by Trolltech AS of Norway and appearing in    */
/* the file LICENSE.QPL included in the packaging of this file.         */
/*                                                                      */
/* Licensees holding valid specific licenses issued by INRIA, CNRS or   */
/* Universite Rennes 1 for the software may use this file in            */
/* acordance with that specific license                                 */
/************************************************************************/
/************************************************************************/
/* WARNING : GENERATED FILE. DO NOT MODIFY IT.                          */
/* Generated the 2006-09-12 at 18:00:29                                 */
/* Generated by omk version 1.2.0                                       */
/* Use just as it is or derive this class to add the  necessary         */
/* functions.                                                           */
/************************************************************************/
/************************************************************************/
		

#include "ovkPsTypeChunk.h"
#include <PsSimulatedObject.h>
#include <PsParametersAccessor.h>
#include <vector>
#include <string>
#include <iostream>

using namespace OpenViBE;
using namespace OpenViBE::Kernel;
using namespace OpenViBE::Kernel::Player;

std::ostream& operator<<(std::ostream& rStream, const CBuffer& rBuffer)
{
	rStream<<rBuffer.getSize();
	for(uint32 i=0; i<rBuffer.getSize(); i++)
	{
		rStream<<rBuffer.getDirectPointer()[i];
	}
	return rStream;
}

std::istream& operator>>(std::istream& rStream, CBuffer& rBuffer)
{
	uint32 l_ui32Size;
	rStream>>l_ui32Size;
	rBuffer.setSize(l_ui32Size);
	for(uint32 i=0; i<l_ui32Size; i++)
	{
		rStream>>rBuffer.getDirectPointer()[i];
	}
	return rStream;
}

PsOutgoingSynchronisationMessage& operator<<(PsOutgoingSynchronisationMessage& rStream, const CBuffer& rBuffer)
{
	rStream<<rBuffer.getSize();
	for(uint32 i=0; i<rBuffer.getSize(); i++)
	{
		rStream<<rBuffer.getDirectPointer()[i];
	}
	return rStream;
}

PsIncomingSynchronisationMessage& operator>>(PsIncomingSynchronisationMessage& rStream, CBuffer& rBuffer)
{
	uint32 l_ui32Size;
	rStream>>l_ui32Size;
	rBuffer.setSize(l_ui32Size);
	for(uint32 i=0; i<l_ui32Size; i++)
	{
		rStream.get(((char*)rBuffer.getDirectPointer())[i]); // $$$$$$$$$$$$$
	}
	return rStream;
}

//========================================================================
// Default constructor
PsTypeChunk::PsTypeChunk()
: PsType(),
	m_bDeprecated(false) ,
	m_bReadyToSend(false)
{
}

//========================================================================
// Copy constructor
PsTypeChunk::PsTypeChunk( const PsTypeChunk& ref )
: PsType(),
	m_bDeprecated(false) ,
	m_bReadyToSend(false)
{
  _copy( ref ) ;
}

//========================================================================
// Constructor with the parameters
PsTypeChunk::PsTypeChunk( int ioConnectorIndex,
                            int startTime,
                            int endTime,
                            const CBuffer& buffer)
: PsType(),
	_ioConnectorIndex( ioConnectorIndex ) ,
	_startTime( startTime ) ,
	_endTime( endTime ) ,
	_buffer( buffer ) ,
	m_bDeprecated(false) ,
	m_bReadyToSend(false)
{
}

//========================================================================
// Destructor
PsTypeChunk::~PsTypeChunk()
{
}

//========================================================================
// Default values for parameters
void PsTypeChunk::resetDefaultValues()
{
	//=== Reset default parameters
	// No parameters to reset => Nothing to do
}

//========================================================================
// Configuration parameters loader
bool PsTypeChunk::loadParameters( PsSimulatedObject* p, const std::string& prefix )
{
	// Get the configuration parameter node of the user param in the simulated object
	return loadParameters( p ? p->getConfigurationParameters() : 0, prefix, p ) ;
}

//========================================================================
// Configuration parameters loader
bool PsTypeChunk::loadParameters( const PsConfigurationParameterDescriptor * node,
                               const std::string& prefix,
                               PsSimulatedObject* p )
{
	resetDefaultValues() ;
	return innerParametersLoader( node, prefix, p );
}
//========================================================================
// Configuration parameters loader
bool PsTypeChunk::innerParametersLoader( const PsConfigurationParameterDescriptor * node, const std::string& prefix, PsSimulatedObject* p )
{
	// Tests the configuration parameter node
	if( !node )
	{ // No valid node => display error message and return false
		std::cerr << ":-( Error in PsTypeChunk::innerParametersLoader";
		if( p ) std::cerr << " for object \"" << p->getName().getPsString()
		                  << "\" (class " << p->getObjectDescriptor().getClass().getPsString() << ")" ;
		std::cerr << std::endl << ">>> Invalid node" << std::endl ; 
		return false ;
	}

	//=== The optional parameters => no test
	// Load the value of IoConnectorIndex
	PsParametersAccessor::get( node, prefix + "IoConnectorIndex", _ioConnectorIndex ) ;
	// Load the value of StartTime
	PsParametersAccessor::get( node, prefix + "StartTime", _startTime ) ;
	// Load the value of EndTime
	PsParametersAccessor::get( node, prefix + "EndTime", _endTime ) ;
	// Load the value of Buffer
	PsParametersAccessor::get( node, prefix + "Buffer", _buffer ) ;

	// No validation requiered, always true if valid node was given
	return true ;
}

//========================================================================
// != operator
bool PsTypeChunk::operator != ( const PsTypeChunk& ref ) const
{
	return true;
}

//========================================================================
// copy operator
PsTypeChunk& PsTypeChunk::operator = ( const PsTypeChunk& ref )
{
	if ( this != &ref )
	{
		_copy( ref ) ;
	}
	return *this ;
}

//========================================================================
// insert in stream
void PsTypeChunk::insertInStream( std::ostream& out ) const
{
	out << getIoConnectorIndex() << " "
	    << getStartTime() << " "
	    << getEndTime() << " "
	    << getBuffer() << " "
	    << " " ;
}

//========================================================================
// extract from a stream
void PsTypeChunk::extract( std::istream& in )
{
	in >> _ioConnectorIndex
	   >> _startTime
	   >> _endTime
	   >> _buffer ;
}

//========================================================================
// pack
void PsTypeChunk::pack( PsOutgoingSynchronisationMessage& out ) const
{
	out << getIoConnectorIndex()
	    << getStartTime()
	    << getEndTime()
	    << getBuffer() ;
}

//========================================================================
// unpack
void PsTypeChunk::unpack( PsIncomingSynchronisationMessage& in )
{
	in >> _ioConnectorIndex
	   >> _startTime
	   >> _endTime
	   >> _buffer ;
}

//========================================================================
// create a default polator
PsPolatorNT* PsTypeChunk::createPolator()
{
	return new PsPolator<PsTypeChunk>() ;
}

//========================================================================
// Protected copy methods
void PsTypeChunk::_copy( const PsTypeChunk& ref )
{
	_ioConnectorIndex = ref.getIoConnectorIndex() ;
	_startTime = ref.getStartTime() ;
	_endTime = ref.getEndTime() ;
	_buffer = ref.getBuffer() ;
}

//========================================================================
