
/************************************************************************/
/* This file is part of openMask(c) INRIA, CNRS, Universite de Rennes 1 */
/* 1993-2002, thereinafter the Software                                 */
/*                                                                      */
/* The Software has been developped within the Siames Project.          */
/* INRIA, the University of Rennes 1 and CNRS jointly hold intellectual */
/* property rights                                                      */
/*                                                                      */
/* The Software has been registered with the Agence pour la Protection  */
/* des Programmes (APP) under registration number                       */
/* IDDN.FR.001.510008.00.S.P.2001.000.41200                             */
/*                                                                      */
/* This file may be distributed under the terms of the Q Public License */
/* version 1.0 as defined by Trolltech AS of Norway and appearing in    */
/* the file LICENSE.QPL included in the packaging of this file.         */
/*                                                                      */
/* Licensees holding valid specific licenses issued by INRIA, CNRS or   */
/* Universite Rennes 1 for the software may use this file in            */
/* acordance with that specific license                                 */
/************************************************************************/
/************************************************************************/
/* WARNING : GENERATED FILE. DO NOT MODIFY IT.                          */
/* Generated the 2006-09-12 at 18:00:28                                 */
/* Generated by omk version 1.2.0                                       */
/* Use just as it is or derive this class to add the  necessary         */
/* functions.                                                           */
/************************************************************************/
/************************************************************************/


#include "ovkPsSimulatedBoxBase.h"
#include <PsParametersAccessor.h>
#include <vector>
#include <string>
#include <iostream>

//========================================================================
// Default constructor
PsSimulatedBoxBase::PsSimulatedBoxBase( PsController& ctrl, const PsObjectDescriptor& objectDescriptor )
: PsSimulatedObject( ctrl, objectDescriptor )
{
  _exitOnInitError = false ;
 }

//========================================================================
// Destructor
PsSimulatedBoxBase::~PsSimulatedBoxBase()
{
}
//========================================================================
// Default values for parameters
void PsSimulatedBoxBase::resetDefaultValues()
{
  //=== Reset default parameters
  // No parameters to reset => Nothing to do
}
		//========================================================================
// Configuration parameters loader
bool PsSimulatedBoxBase::loadAttributsParameters( const PsConfigurationParameterDescriptor * node )
{
  // Tests the configuration parameter node
  if( !node )
  { // No valid node => display error message and return false
    std::cerr << ":-( Error in PsSimulatedBoxBase::loadAttributsParameters for object \"" << getName().getPsString() << "\""
              << "\" (class " << getObjectDescriptor().getClass().getPsString() << ")"
              << std::endl << ">>> Invalid node" << std::endl ;
    return false ;
  }

  // No validation requiered, always true if valid node was given
  return true ;
}
		//========================================================================
// Creates events listeners and associates them to their callback method.
// Reads in the configuration node the values to register signals.
bool PsSimulatedBoxBase::loadEventsConnectionsParameters( const PsConfigurationParameterDescriptor * node )
{
  // the return value
  bool ok = true ;
  _openViBEDataUpdateEventListener = new PsValuedEventListenerCallBack< ::PsSimulatedBoxBase, ::PsTypeChunk > ( *this, &PsSimulatedBoxBase::processOpenViBEDataUpdateEvent, EventId::s_openViBEDataUpdate ) ;
  ok = _openViBEDataUpdateEventListener && ok ;
  _maskStartEventListener = new PsEventListenerCallBack< ::PsSimulatedBoxBase > ( *this, &PsSimulatedBoxBase::processMaskStartEvent, PsSystemEventIdentifier::MaskStart ) ;
  ok = _maskStartEventListener && ok ;
  _maskStopEventListener = new PsEventListenerCallBack< ::PsSimulatedBoxBase > ( *this, &PsSimulatedBoxBase::processMaskStopEvent, PsSystemEventIdentifier::MaskStop ) ;
  ok = _maskStopEventListener && ok ;
  // one or more listeners cannot be created => error
  if( !ok )
  {
    std::cerr << ":-( Error in PsSimulatedBoxBase::loadEventsConnectionsParameters for object \"" << getName().getPsString() << "\" (class "
              << getObjectDescriptor().getClass().getPsString() << ")" << std::endl
              << ">>> One or more listeners cannot be created => Unable to initialize" << std::endl ;
    exit( -1 ) ;
  }

  // Tests the configuration parameter node
  ok = !node && ok ;

  // Temporary boolean to get the broadcast state
  bool listenSignal = true ;
  // Temporary name vector to get the listened object
  std::vector<std::string> listenedObjects ;

  // Reads parameters for signal "OpenViBEDataUpdate"
  // Gets the registration for the broadcast signal
  if( ok && PsParametersAccessor::get( node, "ListenOpenViBEDataUpdate", listenSignal )
    && listenSignal )
    registerForOpenViBEDataUpdateSignal() ;
  // Gets the registration for listened objects
  listenedObjects.clear() ;
  if( ok && PsParametersAccessor::getVector( node, "ListenOpenViBEDataUpdateBy", listenedObjects ) )
  {
    for( unsigned int i = 0 ; i < listenedObjects.size() ; i++ )
      registerForOpenViBEDataUpdateSignalBy( listenedObjects[ i ] ) ;
  }

  return ok ;
}
//========================================================================
// Initialisation
void PsSimulatedBoxBase::init()
{
  const PsConfigurationParameterDescriptor* node = getConfigurationParameters();
  // Test the configuration parameter node
  if( !node )
  {
    std::cerr << ":-( Error in PsSimulatedBoxBase::init for object \"" << getName().getPsString() << "\" (class "
              << getObjectDescriptor().getClass().getPsString() << ")" << std::endl
              << ">>> Invalid node => Unable to initialize" << std::endl ;
    // Must exit or return
    if( _exitOnInitError ) exit( -1 ) ; else return ;
  }
  bool ok = true ;
  // Reset default parameters
  resetDefaultValues() ;
  // Load attributs
  ok = loadAttributsParameters  ( node ) && ok ;
  // Load connections
  ok = loadInputsConnectionsParameters( node ) && ok ;
  // Load connections
  ok = loadEventsConnectionsParameters( node ) && ok ;
  if( !ok && _exitOnInitError )
  { // Not ok, display the following message and exit
    std::cerr << ":-( Error in PsSimulatedBoxBase::init for object \"" << getName().getPsString() << "\" (class "
              << getObjectDescriptor().getClass().getPsString() << ")" << std::endl
              << ">>> Unable to initialize the object" << std::endl ;
    exit( -1 ) ;
  }
}
//========================================================================
void PsSimulatedBoxBase::compute()
{
  computeInputs    ();
  computeParameters();
  computeOutputs   ();
}

//========================================================================
//No need to call this method in the overwrite method of the sons
bool PsSimulatedBoxBase::processOpenViBEDataUpdateEvent( ::PsValuedEvent< ::PsTypeChunk > *e )
{
  std::cerr << ":-( Warning in PsSimulatedBoxBase:: processOpenViBEDataUpdateEvent for object \""
            << getName().getPsString() << "\" (class "
            << getObjectDescriptor().getClass().getPsString() << ")"
            << std::endl
            << ">>> Not yet implemented" << std::endl ;
  return true ;
}

//========================================================================
//No need to call this method in the overwrite method of the sons
bool PsSimulatedBoxBase::processMaskStartEvent( ::PsEvent *e )
{
  std::cerr << ":-( Warning in PsSimulatedBoxBase:: processMaskStartEvent for object \""
            << getName().getPsString() << "\" (class "
            << getObjectDescriptor().getClass().getPsString() << ")"
            << std::endl
            << ">>> Not yet implemented" << std::endl ;
  return true ;
}

//========================================================================
//No need to call this method in the overwrite method of the sons
bool PsSimulatedBoxBase::processMaskStopEvent( ::PsEvent *e )
{
  std::cerr << ":-( Warning in PsSimulatedBoxBase:: processMaskStopEvent for object \""
            << getName().getPsString() << "\" (class "
            << getObjectDescriptor().getClass().getPsString() << ")"
            << std::endl
            << ">>> Not yet implemented" << std::endl ;
  return true ;
}

//========================================================================
